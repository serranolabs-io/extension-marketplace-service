/*
 * Extension Config API
 *
 * API to submit and publish an ExtensionConfig object
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path"
	"time"

	"github.com/charmbracelet/log"
	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/transport/ssh"
	"github.com/google/uuid"
	"github.com/supabase-community/supabase-go"
)

const DEPLOY_KEY_PATH = "deploy_key.pem"

const PACKAGE_JSON = "package.json"
const CONFIG_JSON = "config.json"

func (e *Extension) createFile(fileName string, key string, repoPath string, worktree *git.Worktree) {
	err := os.WriteFile(path.Join(repoPath, fileName), []byte(key), 0755)

	if err != nil {
		log.Fatalf("Failed to create file: %v", err)
	}

	_, err = worktree.Add(fileName)
	if err != nil {
		log.Fatalf("Failed to add file to repository: %v", err)
	}

}

func (e *Extension) createDirectory(repo *git.Repository, repoPath string, worktree *git.Worktree) string {
	newUserDir := fmt.Sprintf("packages/extensions/configs/%s", e.UserId)
	err := os.MkdirAll(path.Join(repoPath, newUserDir), os.ModePerm)
	if err != nil {
		log.Fatalf("Failed to create directory: %v", err)
	}

	_, err = worktree.Add(newUserDir)
	if err != nil {
		log.Fatalf("Failed to add directory to repository: %v", err)
	}

	newConfigDir := path.Join(newUserDir, e.Name)
	err = os.MkdirAll(path.Join(repoPath, newConfigDir), os.ModePerm)
	if err != nil {
		log.Fatalf("Failed to create directory: %v", err)
	}

	_, err = worktree.Add(newConfigDir)
	if err != nil {
		log.Fatalf("Failed to add directory to repository: %v", err)
	}

	return newConfigDir
}

func (e *Extension) createExtension() {
	if e.Config == "" {
		log.Info("Error: Config is empty")
		return
	}

	// Clone the repository
	repoPath := "./temp-repo"
	sshKey, err := os.ReadFile(DEPLOY_KEY_PATH)
	if err != nil {
		log.Fatalf("Failed to read deploy key file: %v", err)
	}

	// os.Setenv("SSH_KNOWN_HOSTS", SSH_KNOWN_HOSTS_PATH)

	publicKeys, err := ssh.NewPublicKeys("git", sshKey, "")

	if err != nil {
		log.Fatalf("Failed to create public keys from private key: %v", err)
	}

	publicKeys.HostKeyCallback, err = ssh.NewKnownHostsCallback()
	if err != nil {
		log.Fatalf("Failed to create public keys from private key: %v", err)
	}

	repo, err := git.PlainClone(repoPath, false, &git.CloneOptions{
		URL:      "git@github.com:serranolabs-io/bookera-extension-hub.git",
		Auth:     publicKeys,
		Progress: os.Stdout,
	})
	if err != nil {
		if err == git.ErrRepositoryAlreadyExists {
			log.Info("Repository already exists, proceeding with existing repository")
			repo, err = git.PlainOpen(repoPath)
			if err != nil {
				log.Fatalf("Failed to open existing repository: %v", err)
			}
		} else {
			log.Fatalf("Failed to clone repository: %v", err)
		}
	}

	// Create a new file with the extension config

	// Add the file to the repository
	worktree, err := repo.Worktree()
	if err != nil {
		log.Fatalf("Failed to get worktree: %v", err)
	}

	newConfigFile := e.createDirectory(repo, repoPath, worktree)

	configFile := path.Join(newConfigFile, CONFIG_JSON)
	e.createFile(configFile, e.Config, repoPath, worktree)
	packageJson := path.Join(newConfigFile, PACKAGE_JSON)
	e.createFile(packageJson, e.PackageJson, repoPath, worktree)

	msg := fmt.Sprintf("Extension config '%s' for user '%s' created", e.Name, e.UserId)
	// Commit the changes
	_, err = worktree.Commit(msg, &git.CommitOptions{
		Author: &object.Signature{
			Name:  "Updated config",
			Email: "daviddserranodev@gmail.cm",
			When:  time.Now(),
		},
	})
	if err != nil {
		log.Fatalf("Failed to commit changes: %v", err)
	}

	// Push the changes to the remote repository
	err = repo.Push(&git.PushOptions{
		Auth: publicKeys,
	})
	if err != nil {
		if err.Error() == "non-fast-forward update: refs/heads/main" {
			log.Warn("Non-fast-forward update detected, changes not pushed")
			err = repo.Fetch(&git.FetchOptions{
				Auth: publicKeys,
			})
			if err != nil {
				log.Fatalf("Failed to fetch changes: %v", err)
			}

			err = repo.Push(&git.PushOptions{
				Auth: publicKeys,
			})

			if err != nil {
				log.Fatalf("Failed to push changes after rebase: %v", err)
			}

		} else {
			log.Fatalf("Failed to push changes: %v", err)
		}
	}

	log.Info(msg + " and pushed to repository")
}

func readEndpoint(fileName string, getFullDirectory bool) string {
	getFullDirectorySuffix := ""
	if getFullDirectory {
		getFullDirectorySuffix = "?ref=main"
	}

	client := &http.Client{}
	req, err := http.NewRequest("GET", fmt.Sprintf("https://%s%s", fileName, getFullDirectorySuffix), nil)
	if err != nil {
		log.Fatalf("Failed to create request: %v", err)
	}

	req.Header.Set("Accept", "application/vnd.github+json")
	secret := os.Getenv("GIT_SECRET")
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", secret))

	resp, err := client.Do(req)
	if err != nil {
		log.Fatalf("Failed to fetch data: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Fatalf("Failed to fetch data, status code: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Failed to read response body: %v", err)
	}

	// Process the response body as needed
	return string(body)
}

func getFullDirectory() string {
	filePath := fmt.Sprintf("/packages/extensions/configs")
	// filePath := ""
	return fmt.Sprintf("api.github.com/repos/serranolabs-io/bookera-extension-hub/contents%s", filePath)
}

func getDirectory(id string, userName string) string {
	filePath := fmt.Sprintf("/packages/extensions/configs/%s/%s", userName, id)
	// filePath := ""
	return fmt.Sprintf("raw.githubusercontent.com/serranolabs-io/bookera-extension-hub/main%s", filePath)
}

const (
	EXTENSION_TABLE = "Extension"
)

type ExtensionTable struct {
	ID int64 `json:"id"`

	// int8 corresponds to int64 in Go
	UserID uuid.UUID `json:"userId"`

	// uuid type

	Name string `json:"name"`

	// text type
}

func getAllExtensions(supabaseClient *supabase.Client) []*Extension {
	var extensionTables []ExtensionTable
	data, _, err := supabaseClient.From(EXTENSION_TABLE).Select("*", "exact", false).Execute()

	if err != nil {
		log.Fatalf("Failed to fetch extensions: %v", err)
	}

	err = json.Unmarshal([]byte(data), &extensionTables)
	if err != nil {
		log.Fatalf("Failed to parse extensions: %v", err)
	}

	extensions := []*Extension{}

	for _, extensionTable := range extensionTables {
		extension := getExtension(extensionTable.Name, extensionTable.UserID.String())
		extension.Id = float32(extensionTable.ID)
		extensions = append(extensions, extension)
	}

	return extensions
}

func getExtension(id string, userId string) *Extension {
	extension := &Extension{}

	directory := getDirectory(id, userId)
	packgeJson := readEndpoint(path.Join(directory, PACKAGE_JSON), false)
	configJson := readEndpoint(path.Join(directory, CONFIG_JSON), false)

	extension.PackageJson = packgeJson
	extension.Config = configJson

	return extension
}
