/*
 * Extension Config API
 *
 * API to submit and publish an ExtensionConfig object
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/json"
	"fmt"
	"io"
	"mime"
	"mime/multipart"
	"net/http"
	"os"
	"path"
	"path/filepath"

	"github.com/charmbracelet/log"
	"github.com/go-git/go-git/v5"
	"github.com/google/uuid"
	"github.com/supabase-community/supabase-go"
)

const DEPLOY_KEY_PATH = "deploy_key.pem"

const PACKAGE_JSON = "package.json"
const CONFIG_JSON = "config.json"

func (e *Extension) createFile(fileName string, key string, repoPath string, worktree *git.Worktree) {
	err := os.WriteFile(path.Join(repoPath, fileName), []byte(key), 0755)

	if err != nil {
		log.Fatalf("Failed to create file: %v", err)
	}

	_, err = worktree.Add(fileName)
	if err != nil {
		log.Fatalf("Failed to add file to repository: %v", err)
	}

}

func (e *Extension) createDirectory(repo *git.Repository, repoPath string, worktree *git.Worktree) string {
	newUserDir := fmt.Sprintf("packages/extensions/configs/%s", e.UserId)
	err := os.MkdirAll(path.Join(repoPath, newUserDir), os.ModePerm)
	if err != nil {
		log.Fatalf("Failed to create directory: %v", err)
	}

	_, err = worktree.Add(newUserDir)
	if err != nil {
		log.Fatalf("Failed to add directory to repository: %v", err)
	}

	newConfigDir := path.Join(newUserDir, e.Name)
	err = os.MkdirAll(path.Join(repoPath, newConfigDir), os.ModePerm)
	if err != nil {
		log.Fatalf("Failed to create directory: %v", err)
	}

	_, err = worktree.Add(newConfigDir)
	if err != nil {
		log.Fatalf("Failed to add directory to repository: %v", err)
	}

	return newConfigDir
}

func (e *Extension) createExtension() {
	repo, worktree, publicKeys, repoPath := initGitRepo()

	newConfigFile := e.createDirectory(repo, repoPath, worktree)
	configFile := path.Join(newConfigFile, CONFIG_JSON)
	e.createFile(configFile, e.Config, repoPath, worktree)
	packageJson := path.Join(newConfigFile, PACKAGE_JSON)
	e.createFile(packageJson, e.PackageJson, repoPath, worktree)

	msg := fmt.Sprintf("Extension config '%s' for user '%s' created", e.Name, e.UserId)
	commitChanges(msg, worktree, repo, publicKeys)
}

func readEndpoint(fileName string, getFullDirectory bool) string {
	getFullDirectorySuffix := ""
	if getFullDirectory {
		getFullDirectorySuffix = "?ref=main"
	}

	client := &http.Client{}
	req, err := http.NewRequest("GET", fmt.Sprintf("https://%s%s", fileName, getFullDirectorySuffix), nil)
	if err != nil {
		log.Fatalf("Failed to create request: %v", err)
	}

	req.Header.Set("Accept", "application/vnd.github+json")
	secret := os.Getenv("GIT_SECRET")
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", secret))

	resp, err := client.Do(req)
	if err != nil {
		log.Fatalf("Failed to make request %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Fatalf("your database has a row that does not exist in github %v", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Failed to read response body: %v", err)
	}

	// Process the response body as needed
	return string(body)
}

func getFullDirectory() string {
	filePath := fmt.Sprintf("/packages/extensions/configs")
	// filePath := ""
	return fmt.Sprintf("api.github.com/repos/serranolabs-io/bookera-extension-hub/contents%s", filePath)
}

func getUserDirectory(id string, userName string) string {
	return fmt.Sprintf("/packages/extensions/configs/%s/%s", userName, id)
}

func getDirectory(id string, userName string) string {
	// filePath := ""
	return fmt.Sprintf("raw.githubusercontent.com/serranolabs-io/bookera-extension-hub/main%s", getUserDirectory(id, userName))
}

const (
	EXTENSION_TABLE = "Extension"
)

type ExtensionTable struct {
	ID int64 `json:"id"`

	// int8 corresponds to int64 in Go
	UserID uuid.UUID `json:"userId"`

	// uuid type

	Name string `json:"name"`

	// text type
	HasIcon bool `json:"hasIcon"`

	// text type
	IsPublished bool `json:"isPublished"`

	IsDownloaded bool `json:"isDownloaded"`
}

type GetAllExtensionsOptions struct {
	IsPublished     bool
	UserId          string
	filterByUserId  string
	isDownloaded    bool
	isDownloadedSet bool `json:"isDownloadedSet"`
}

func getAllExtensions(supabaseClient *supabase.Client, options GetAllExtensionsOptions) []*Extension {
	var extensionTables []ExtensionTable

	var result string
	if options.filterByUserId == "" {
		rpcParams := map[string]interface{}{
			"is_published": options.IsPublished,
		}

		if options.UserId != "" {
			rpcParams["logged_user_id"] = options.UserId
		}

		result = supabaseClient.Rpc("getallextensionsjoindownloaded", "", rpcParams)
	} else {
		rpcParams := map[string]interface{}{
			"logged_user_id":    options.UserId,
			"is_published":      options.IsPublished,
			"filter_by_user_id": options.filterByUserId,
		}

		if options.UserId != "" {
			rpcParams["logged_user_id"] = options.UserId
		}
		result = supabaseClient.Rpc("getallextensionsjoindownloaded", "", rpcParams)
	}

	err := json.Unmarshal([]byte(result), &extensionTables)
	if err != nil {
		log.Fatalf("Failed to fetch extensions: %v", err)
	}

	extensions := []*Extension{}

	for _, extensionTable := range extensionTables {
		// filtering by isDownloaded
		if options.isDownloadedSet && !(options.isDownloaded == extensionTable.IsDownloaded) {
			continue
		}

		extension := getExtension(extensionTable.Name, extensionTable.UserID.String())
		extension.Id = float32(extensionTable.ID)
		extension.UserId = extensionTable.UserID.String()
		extension.Name = extensionTable.Name
		extension.HasIcon = extensionTable.HasIcon
		extension.IsPublished = extensionTable.IsPublished
		extension.IsDownloaded = extensionTable.IsDownloaded
		extensions = append(extensions, extension)
	}

	return extensions
}

func getExtension(id string, userId string) *Extension {
	extension := &Extension{}

	directory := getDirectory(id, userId)
	packgeJson := readEndpoint(path.Join(directory, PACKAGE_JSON), false)
	configJson := readEndpoint(path.Join(directory, CONFIG_JSON), false)

	extension.PackageJson = packgeJson
	extension.Config = configJson

	return extension
}

func createIcon(file multipart.File, header *multipart.FileHeader, repoPath string, worktree *git.Worktree, extensionTable ExtensionTable) error {
	// Ensure the target directory exists
	ICONS_DIR_PATH := path.Join(getUserDirectory(extensionTable.Name, extensionTable.UserID.String()), "icons")
	fullIconDirPath := path.Join(repoPath, ICONS_DIR_PATH)
	err := os.MkdirAll(fullIconDirPath, os.ModePerm)
	if err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}

	// Extract the file extension from the Content-Type header
	contentType := header.Header.Get("Content-Type")
	if contentType == "" {
		return fmt.Errorf("Content-Type header is missing")
	}

	fileExt, err := mime.ExtensionsByType(contentType)
	if err != nil || len(fileExt) == 0 {
		return fmt.Errorf("failed to determine file extension from Content-Type: %v", err)
	}

	// Use the first extension from the list
	fileExtStr := fileExt[0]

	newFilePath := fmt.Sprintf("96x96%s", fileExtStr)
	// Create the full file path
	fullFilePath := filepath.Join(fullIconDirPath, newFilePath)

	// Create the destination file
	destFile, err := os.Create(fullFilePath)
	if err != nil {
		return fmt.Errorf("failed to create file: %v", err)
	}
	defer destFile.Close()

	// Copy the file content to the destination
	_, err = io.Copy(destFile, file)
	if err != nil {
		return fmt.Errorf("failed to save file: %v", err)
	}

	_, err = worktree.Add(".")
	if err != nil {
		log.Fatalf("Failed to add icon to repository: %v", err)
	}

	log.Info("icon added successfully", "icon", newFilePath)
	return nil
}

// why do we need userId?
func updateUserExtensionImage(supabaseClient *supabase.Client, configId string, file multipart.File, header *multipart.FileHeader) {
	// & retrieve name of from backend
	var extensionTables []ExtensionTable
	data, _, err := supabaseClient.From(EXTENSION_TABLE).Select("*", "exact", false).Eq("id", configId).Execute()

	if err != nil {
		log.Fatalf("Failed to fetch extensions: %v", err)
	}

	err = json.Unmarshal([]byte(data), &extensionTables)
	if err != nil {
		log.Fatalf("Failed to parse extensions: %v", err)
	}

	userExtensionTable := extensionTables[0]

	// & within repo directory, add icon directory
	// & 96x96
	repo, worktree, publicKeys, repoPath := initGitRepo()
	createIcon(file, header, repoPath, worktree, userExtensionTable)

	msg := fmt.Sprintf("Icon for extension config '%s' for user '%s' created", userExtensionTable.Name, userExtensionTable.UserID)
	commitChanges(msg, worktree, repo, publicKeys)

	_, _, err = supabaseClient.From(EXTENSION_TABLE).Update(map[string]interface{}{"hasIcon": true}, "exact", "").Eq("id", configId).Execute()

	if err != nil {
		log.Fatalf("Failed to update hasIcon field: %v", err)
	}

}
